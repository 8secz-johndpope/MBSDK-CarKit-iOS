// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vehicle-commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto_Door: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json (de)serialization purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownDoor // = 0
  case frontleft // = 1
  case frontright // = 2
  case rearleft // = 3
  case rearright // = 4
  case trunk // = 5
  case fuelflap // = 6
  case chargeflap // = 7
  case chargecoupler // = 8
  static let frontLeft = frontleft
  static let frontRight = frontright
  static let rearLeft = rearleft
  static let rearRight = rearright
  static let fuelFlap = fuelflap
  static let chargeFlap = chargeflap
  static let chargeCoupler = chargecoupler
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDoor
    case 1: self = .frontleft
    case 2: self = .frontright
    case 3: self = .rearleft
    case 4: self = .rearright
    case 5: self = .trunk
    case 6: self = .fuelflap
    case 7: self = .chargeflap
    case 8: self = .chargecoupler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDoor: return 0
    case .frontleft: return 1
    case .frontright: return 2
    case .rearleft: return 3
    case .rearright: return 4
    case .trunk: return 5
    case .fuelflap: return 6
    case .chargeflap: return 7
    case .chargecoupler: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Door: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_Door] = [
    .unknownDoor,
    .frontleft,
    .frontright,
    .rearleft,
    .rearright,
    .trunk,
    .fuelflap,
    .chargeflap,
    .chargecoupler,
  ]
}

#endif  // swift(>=4.2)

enum Proto_ZEVPreconditioningType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownZevPreconditioningCommandType // = 0
  case immediate // = 1
  case departure // = 2
  case now // = 3
  case departureWeekly // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownZevPreconditioningCommandType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownZevPreconditioningCommandType
    case 1: self = .immediate
    case 2: self = .departure
    case 3: self = .now
    case 4: self = .departureWeekly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownZevPreconditioningCommandType: return 0
    case .immediate: return 1
    case .departure: return 2
    case .now: return 3
    case .departureWeekly: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningType] = [
    .unknownZevPreconditioningCommandType,
    .immediate,
    .departure,
    .now,
    .departureWeekly,
  ]
}

#endif  // swift(>=4.2)

enum Proto_TimeProfileDay: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the short versions are for json (en)coding purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case mo // = 0
  case tu // = 1
  case we // = 2
  case th // = 3
  case fr // = 4
  case sa // = 5
  case su // = 6
  static let monday = mo
  static let tuesday = tu
  static let wednesday = we
  static let thursday = th
  static let friday = fr
  static let saturday = sa
  static let sunday = su
  case UNRECOGNIZED(Int)

  init() {
    self = .mo
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mo
    case 1: self = .tu
    case 2: self = .we
    case 3: self = .th
    case 4: self = .fr
    case 5: self = .sa
    case 6: self = .su
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mo: return 0
    case .tu: return 1
    case .we: return 2
    case .th: return 3
    case .fr: return 4
    case .sa: return 5
    case .su: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TimeProfileDay: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_TimeProfileDay] = [
    .mo,
    .tu,
    .we,
    .th,
    .fr,
    .sa,
    .su,
  ]
}

#endif  // swift(>=4.2)

enum Proto_DriveType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDriveType // = 0
  case pickUp // = 1
  case dropOff // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDriveType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDriveType
    case 1: self = .pickUp
    case 2: self = .dropOff
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDriveType: return 0
    case .pickUp: return 1
    case .dropOff: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DriveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_DriveType] = [
    .unknownDriveType,
    .pickUp,
    .dropOff,
  ]
}

#endif  // swift(>=4.2)

/// Acknowledge the CommandRequest reached the apptwin actor
/// Websocket <- Apptwin
struct Proto_AcknowledgeCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// After the command was issued at VVA based on this
/// command request the call will get a command request
/// correlation message which matches the request id
/// with the process id.
/// Sending direction: App - BFF -> AppTwin
struct Proto_CommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String {
    get {return _storage._vin}
    set {_uniqueStorage()._vin = newValue}
  }

  /// Set this id to correlate a CommandStatus
  /// with this command request.
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  var backend: Proto_CommandRequest.Backend {
    get {return _storage._backend}
    set {_uniqueStorage()._backend = newValue}
  }

  var command: OneOf_Command? {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  var auxheatStart: Proto_AuxheatStart {
    get {
      if case .auxheatStart(let v)? = _storage._command {return v}
      return Proto_AuxheatStart()
    }
    set {_uniqueStorage()._command = .auxheatStart(newValue)}
  }

  var auxheatStop: Proto_AuxheatStop {
    get {
      if case .auxheatStop(let v)? = _storage._command {return v}
      return Proto_AuxheatStop()
    }
    set {_uniqueStorage()._command = .auxheatStop(newValue)}
  }

  var auxheatConfigure: Proto_AuxheatConfigure {
    get {
      if case .auxheatConfigure(let v)? = _storage._command {return v}
      return Proto_AuxheatConfigure()
    }
    set {_uniqueStorage()._command = .auxheatConfigure(newValue)}
  }

  var doorsLock: Proto_DoorsLock {
    get {
      if case .doorsLock(let v)? = _storage._command {return v}
      return Proto_DoorsLock()
    }
    set {_uniqueStorage()._command = .doorsLock(newValue)}
  }

  var doorsUnlock: Proto_DoorsUnlock {
    get {
      if case .doorsUnlock(let v)? = _storage._command {return v}
      return Proto_DoorsUnlock()
    }
    set {_uniqueStorage()._command = .doorsUnlock(newValue)}
  }

  var sunroofOpen: Proto_SunroofOpen {
    get {
      if case .sunroofOpen(let v)? = _storage._command {return v}
      return Proto_SunroofOpen()
    }
    set {_uniqueStorage()._command = .sunroofOpen(newValue)}
  }

  var sunroofClose: Proto_SunroofClose {
    get {
      if case .sunroofClose(let v)? = _storage._command {return v}
      return Proto_SunroofClose()
    }
    set {_uniqueStorage()._command = .sunroofClose(newValue)}
  }

  var sunroofLift: Proto_SunroofLift {
    get {
      if case .sunroofLift(let v)? = _storage._command {return v}
      return Proto_SunroofLift()
    }
    set {_uniqueStorage()._command = .sunroofLift(newValue)}
  }

  var sunroofMove: Proto_SunroofMove {
    get {
      if case .sunroofMove(let v)? = _storage._command {return v}
      return Proto_SunroofMove()
    }
    set {_uniqueStorage()._command = .sunroofMove(newValue)}
  }

  var windowsOpen: Proto_WindowsOpen {
    get {
      if case .windowsOpen(let v)? = _storage._command {return v}
      return Proto_WindowsOpen()
    }
    set {_uniqueStorage()._command = .windowsOpen(newValue)}
  }

  var windowsClose: Proto_WindowsClose {
    get {
      if case .windowsClose(let v)? = _storage._command {return v}
      return Proto_WindowsClose()
    }
    set {_uniqueStorage()._command = .windowsClose(newValue)}
  }

  var windowsVentilate: Proto_WindowsVentilate {
    get {
      if case .windowsVentilate(let v)? = _storage._command {return v}
      return Proto_WindowsVentilate()
    }
    set {_uniqueStorage()._command = .windowsVentilate(newValue)}
  }

  var windowsMove: Proto_WindowsMove {
    get {
      if case .windowsMove(let v)? = _storage._command {return v}
      return Proto_WindowsMove()
    }
    set {_uniqueStorage()._command = .windowsMove(newValue)}
  }

  var engineStart: Proto_EngineStart {
    get {
      if case .engineStart(let v)? = _storage._command {return v}
      return Proto_EngineStart()
    }
    set {_uniqueStorage()._command = .engineStart(newValue)}
  }

  var engineStop: Proto_EngineStop {
    get {
      if case .engineStop(let v)? = _storage._command {return v}
      return Proto_EngineStop()
    }
    set {_uniqueStorage()._command = .engineStop(newValue)}
  }

  var zevPreconditioningStart: Proto_ZEVPreconditioningStart {
    get {
      if case .zevPreconditioningStart(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningStart()
    }
    set {_uniqueStorage()._command = .zevPreconditioningStart(newValue)}
  }

  var zevPreconditioningStop: Proto_ZEVPreconditioningStop {
    get {
      if case .zevPreconditioningStop(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningStop()
    }
    set {_uniqueStorage()._command = .zevPreconditioningStop(newValue)}
  }

  var zevPreconditionConfigure: Proto_ZEVPreconditioningConfigure {
    get {
      if case .zevPreconditionConfigure(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningConfigure()
    }
    set {_uniqueStorage()._command = .zevPreconditionConfigure(newValue)}
  }

  var zevPreconditionConfigureSeats: Proto_ZEVPreconditioningConfigureSeats {
    get {
      if case .zevPreconditionConfigureSeats(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningConfigureSeats()
    }
    set {_uniqueStorage()._command = .zevPreconditionConfigureSeats(newValue)}
  }

  var speedalertStart: Proto_SpeedalertStart {
    get {
      if case .speedalertStart(let v)? = _storage._command {return v}
      return Proto_SpeedalertStart()
    }
    set {_uniqueStorage()._command = .speedalertStart(newValue)}
  }

  var speedalertStop: Proto_SpeedalertStop {
    get {
      if case .speedalertStop(let v)? = _storage._command {return v}
      return Proto_SpeedalertStop()
    }
    set {_uniqueStorage()._command = .speedalertStop(newValue)}
  }

  var batteryChargeProgram: Proto_BatteryChargeProgramConfigure {
    get {
      if case .batteryChargeProgram(let v)? = _storage._command {return v}
      return Proto_BatteryChargeProgramConfigure()
    }
    set {_uniqueStorage()._command = .batteryChargeProgram(newValue)}
  }

  var batteryMaxSoc: Proto_BatteryMaxSocConfigure {
    get {
      if case .batteryMaxSoc(let v)? = _storage._command {return v}
      return Proto_BatteryMaxSocConfigure()
    }
    set {_uniqueStorage()._command = .batteryMaxSoc(newValue)}
  }

  var chargeProgramConfigure: Proto_ChargeProgramConfigure {
    get {
      if case .chargeProgramConfigure(let v)? = _storage._command {return v}
      return Proto_ChargeProgramConfigure()
    }
    set {_uniqueStorage()._command = .chargeProgramConfigure(newValue)}
  }

  var chargeControlConfigure: Proto_ChargeControlConfigure {
    get {
      if case .chargeControlConfigure(let v)? = _storage._command {return v}
      return Proto_ChargeControlConfigure()
    }
    set {_uniqueStorage()._command = .chargeControlConfigure(newValue)}
  }

  var chargeOptConfigure: Proto_ChargeOptConfigure {
    get {
      if case .chargeOptConfigure(let v)? = _storage._command {return v}
      return Proto_ChargeOptConfigure()
    }
    set {_uniqueStorage()._command = .chargeOptConfigure(newValue)}
  }

  var chargeOptStart: Proto_ChargeOptStart {
    get {
      if case .chargeOptStart(let v)? = _storage._command {return v}
      return Proto_ChargeOptStart()
    }
    set {_uniqueStorage()._command = .chargeOptStart(newValue)}
  }

  var chargeOptStop: Proto_ChargeOptStop {
    get {
      if case .chargeOptStop(let v)? = _storage._command {return v}
      return Proto_ChargeOptStop()
    }
    set {_uniqueStorage()._command = .chargeOptStop(newValue)}
  }

  var temperatureConfigure: Proto_TemperatureConfigure {
    get {
      if case .temperatureConfigure(let v)? = _storage._command {return v}
      return Proto_TemperatureConfigure()
    }
    set {_uniqueStorage()._command = .temperatureConfigure(newValue)}
  }

  var weekProfileConfigure: Proto_WeekProfileConfigure {
    get {
      if case .weekProfileConfigure(let v)? = _storage._command {return v}
      return Proto_WeekProfileConfigure()
    }
    set {_uniqueStorage()._command = .weekProfileConfigure(newValue)}
  }

  var weekProfileConfigureV2: Proto_WeekProfileConfigureV2 {
    get {
      if case .weekProfileConfigureV2(let v)? = _storage._command {return v}
      return Proto_WeekProfileConfigureV2()
    }
    set {_uniqueStorage()._command = .weekProfileConfigureV2(newValue)}
  }

  var sigposStart: Proto_SigPosStart {
    get {
      if case .sigposStart(let v)? = _storage._command {return v}
      return Proto_SigPosStart()
    }
    set {_uniqueStorage()._command = .sigposStart(newValue)}
  }

  var theftalarmConfirmDamagedetection: Proto_TheftalarmConfirmDamagedetection {
    get {
      if case .theftalarmConfirmDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmConfirmDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmConfirmDamagedetection(newValue)}
  }

  var theftalarmDeselectDamagedetection: Proto_TheftalarmDeselectDamagedetection {
    get {
      if case .theftalarmDeselectDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectDamagedetection(newValue)}
  }

  var theftalarmDeselectInterior: Proto_TheftalarmDeselectInterior {
    get {
      if case .theftalarmDeselectInterior(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectInterior()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectInterior(newValue)}
  }

  var theftalarmDeselectTow: Proto_TheftalarmDeselectTow {
    get {
      if case .theftalarmDeselectTow(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectTow()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectTow(newValue)}
  }

  var theftalarmSelectDamagedetection: Proto_TheftalarmSelectDamagedetection {
    get {
      if case .theftalarmSelectDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmSelectDamagedetection(newValue)}
  }

  var theftalarmSelectInterior: Proto_TheftalarmSelectInterior {
    get {
      if case .theftalarmSelectInterior(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectInterior()
    }
    set {_uniqueStorage()._command = .theftalarmSelectInterior(newValue)}
  }

  var theftalarmSelectTow: Proto_TheftalarmSelectTow {
    get {
      if case .theftalarmSelectTow(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectTow()
    }
    set {_uniqueStorage()._command = .theftalarmSelectTow(newValue)}
  }

  var theftalarmStart: Proto_TheftalarmStart {
    get {
      if case .theftalarmStart(let v)? = _storage._command {return v}
      return Proto_TheftalarmStart()
    }
    set {_uniqueStorage()._command = .theftalarmStart(newValue)}
  }

  var theftalarmStop: Proto_TheftalarmStop {
    get {
      if case .theftalarmStop(let v)? = _storage._command {return v}
      return Proto_TheftalarmStop()
    }
    set {_uniqueStorage()._command = .theftalarmStop(newValue)}
  }

  var automaticValetParkingActivate: Proto_AutomaticValetParkingActivate {
    get {
      if case .automaticValetParkingActivate(let v)? = _storage._command {return v}
      return Proto_AutomaticValetParkingActivate()
    }
    set {_uniqueStorage()._command = .automaticValetParkingActivate(newValue)}
  }

  var chargeFlapUnlock: Proto_ChargeFlapUnlock {
    get {
      if case .chargeFlapUnlock(let v)? = _storage._command {return v}
      return Proto_ChargeFlapUnlock()
    }
    set {_uniqueStorage()._command = .chargeFlapUnlock(newValue)}
  }

  var chargeCouplerUnlock: Proto_ChargeCouplerUnlock {
    get {
      if case .chargeCouplerUnlock(let v)? = _storage._command {return v}
      return Proto_ChargeCouplerUnlock()
    }
    set {_uniqueStorage()._command = .chargeCouplerUnlock(newValue)}
  }

  var deactivateVehicleKeys: Proto_DeactivateVehicleKeys {
    get {
      if case .deactivateVehicleKeys(let v)? = _storage._command {return v}
      return Proto_DeactivateVehicleKeys()
    }
    set {_uniqueStorage()._command = .deactivateVehicleKeys(newValue)}
  }

  var activateVehicleKeys: Proto_ActivateVehicleKeys {
    get {
      if case .activateVehicleKeys(let v)? = _storage._command {return v}
      return Proto_ActivateVehicleKeys()
    }
    set {_uniqueStorage()._command = .activateVehicleKeys(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable {
    case auxheatStart(Proto_AuxheatStart)
    case auxheatStop(Proto_AuxheatStop)
    case auxheatConfigure(Proto_AuxheatConfigure)
    case doorsLock(Proto_DoorsLock)
    case doorsUnlock(Proto_DoorsUnlock)
    case sunroofOpen(Proto_SunroofOpen)
    case sunroofClose(Proto_SunroofClose)
    case sunroofLift(Proto_SunroofLift)
    case sunroofMove(Proto_SunroofMove)
    case windowsOpen(Proto_WindowsOpen)
    case windowsClose(Proto_WindowsClose)
    case windowsVentilate(Proto_WindowsVentilate)
    case windowsMove(Proto_WindowsMove)
    case engineStart(Proto_EngineStart)
    case engineStop(Proto_EngineStop)
    case zevPreconditioningStart(Proto_ZEVPreconditioningStart)
    case zevPreconditioningStop(Proto_ZEVPreconditioningStop)
    case zevPreconditionConfigure(Proto_ZEVPreconditioningConfigure)
    case zevPreconditionConfigureSeats(Proto_ZEVPreconditioningConfigureSeats)
    case speedalertStart(Proto_SpeedalertStart)
    case speedalertStop(Proto_SpeedalertStop)
    case batteryChargeProgram(Proto_BatteryChargeProgramConfigure)
    case batteryMaxSoc(Proto_BatteryMaxSocConfigure)
    case chargeProgramConfigure(Proto_ChargeProgramConfigure)
    case chargeControlConfigure(Proto_ChargeControlConfigure)
    case chargeOptConfigure(Proto_ChargeOptConfigure)
    case chargeOptStart(Proto_ChargeOptStart)
    case chargeOptStop(Proto_ChargeOptStop)
    case temperatureConfigure(Proto_TemperatureConfigure)
    case weekProfileConfigure(Proto_WeekProfileConfigure)
    case weekProfileConfigureV2(Proto_WeekProfileConfigureV2)
    case sigposStart(Proto_SigPosStart)
    case theftalarmConfirmDamagedetection(Proto_TheftalarmConfirmDamagedetection)
    case theftalarmDeselectDamagedetection(Proto_TheftalarmDeselectDamagedetection)
    case theftalarmDeselectInterior(Proto_TheftalarmDeselectInterior)
    case theftalarmDeselectTow(Proto_TheftalarmDeselectTow)
    case theftalarmSelectDamagedetection(Proto_TheftalarmSelectDamagedetection)
    case theftalarmSelectInterior(Proto_TheftalarmSelectInterior)
    case theftalarmSelectTow(Proto_TheftalarmSelectTow)
    case theftalarmStart(Proto_TheftalarmStart)
    case theftalarmStop(Proto_TheftalarmStop)
    case automaticValetParkingActivate(Proto_AutomaticValetParkingActivate)
    case chargeFlapUnlock(Proto_ChargeFlapUnlock)
    case chargeCouplerUnlock(Proto_ChargeCouplerUnlock)
    case deactivateVehicleKeys(Proto_DeactivateVehicleKeys)
    case activateVehicleKeys(Proto_ActivateVehicleKeys)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CommandRequest.OneOf_Command, rhs: Proto_CommandRequest.OneOf_Command) -> Bool {
      switch (lhs, rhs) {
      case (.auxheatStart(let l), .auxheatStart(let r)): return l == r
      case (.auxheatStop(let l), .auxheatStop(let r)): return l == r
      case (.auxheatConfigure(let l), .auxheatConfigure(let r)): return l == r
      case (.doorsLock(let l), .doorsLock(let r)): return l == r
      case (.doorsUnlock(let l), .doorsUnlock(let r)): return l == r
      case (.sunroofOpen(let l), .sunroofOpen(let r)): return l == r
      case (.sunroofClose(let l), .sunroofClose(let r)): return l == r
      case (.sunroofLift(let l), .sunroofLift(let r)): return l == r
      case (.sunroofMove(let l), .sunroofMove(let r)): return l == r
      case (.windowsOpen(let l), .windowsOpen(let r)): return l == r
      case (.windowsClose(let l), .windowsClose(let r)): return l == r
      case (.windowsVentilate(let l), .windowsVentilate(let r)): return l == r
      case (.windowsMove(let l), .windowsMove(let r)): return l == r
      case (.engineStart(let l), .engineStart(let r)): return l == r
      case (.engineStop(let l), .engineStop(let r)): return l == r
      case (.zevPreconditioningStart(let l), .zevPreconditioningStart(let r)): return l == r
      case (.zevPreconditioningStop(let l), .zevPreconditioningStop(let r)): return l == r
      case (.zevPreconditionConfigure(let l), .zevPreconditionConfigure(let r)): return l == r
      case (.zevPreconditionConfigureSeats(let l), .zevPreconditionConfigureSeats(let r)): return l == r
      case (.speedalertStart(let l), .speedalertStart(let r)): return l == r
      case (.speedalertStop(let l), .speedalertStop(let r)): return l == r
      case (.batteryChargeProgram(let l), .batteryChargeProgram(let r)): return l == r
      case (.batteryMaxSoc(let l), .batteryMaxSoc(let r)): return l == r
      case (.chargeProgramConfigure(let l), .chargeProgramConfigure(let r)): return l == r
      case (.chargeControlConfigure(let l), .chargeControlConfigure(let r)): return l == r
      case (.chargeOptConfigure(let l), .chargeOptConfigure(let r)): return l == r
      case (.chargeOptStart(let l), .chargeOptStart(let r)): return l == r
      case (.chargeOptStop(let l), .chargeOptStop(let r)): return l == r
      case (.temperatureConfigure(let l), .temperatureConfigure(let r)): return l == r
      case (.weekProfileConfigure(let l), .weekProfileConfigure(let r)): return l == r
      case (.weekProfileConfigureV2(let l), .weekProfileConfigureV2(let r)): return l == r
      case (.sigposStart(let l), .sigposStart(let r)): return l == r
      case (.theftalarmConfirmDamagedetection(let l), .theftalarmConfirmDamagedetection(let r)): return l == r
      case (.theftalarmDeselectDamagedetection(let l), .theftalarmDeselectDamagedetection(let r)): return l == r
      case (.theftalarmDeselectInterior(let l), .theftalarmDeselectInterior(let r)): return l == r
      case (.theftalarmDeselectTow(let l), .theftalarmDeselectTow(let r)): return l == r
      case (.theftalarmSelectDamagedetection(let l), .theftalarmSelectDamagedetection(let r)): return l == r
      case (.theftalarmSelectInterior(let l), .theftalarmSelectInterior(let r)): return l == r
      case (.theftalarmSelectTow(let l), .theftalarmSelectTow(let r)): return l == r
      case (.theftalarmStart(let l), .theftalarmStart(let r)): return l == r
      case (.theftalarmStop(let l), .theftalarmStop(let r)): return l == r
      case (.automaticValetParkingActivate(let l), .automaticValetParkingActivate(let r)): return l == r
      case (.chargeFlapUnlock(let l), .chargeFlapUnlock(let r)): return l == r
      case (.chargeCouplerUnlock(let l), .chargeCouplerUnlock(let r)): return l == r
      case (.deactivateVehicleKeys(let l), .deactivateVehicleKeys(let r)): return l == r
      case (.activateVehicleKeys(let l), .activateVehicleKeys(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Temporary backend switch field. Will be removed as soon as all commands are migrated to the VehicleAPI
  /// This field only needs to be set if the command is supported by both API from our backend. If this field is removed
  /// don't forget to set the field 36 to reserved.
  enum Backend: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// default value
    case vva // = 0
    case vehicleApi // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .vva
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .vva
      case 1: self = .vehicleApi
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .vva: return 0
      case .vehicleApi: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Proto_CommandRequest.Backend: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandRequest.Backend] = [
    .vva,
    .vehicleApi,
  ]
}

#endif  // swift(>=4.2)

struct Proto_DeactivateVehicleKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var expirationUnix: Int64 = 0

  var expirationSeconds: String = String()

  var expirationMilliseconds: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ActivateVehicleKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var expirationUnix: Int64 = 0

  var expirationSeconds: String = String()

  var expirationMilliseconds: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSelection: Proto_AuxheatConfigure.Selection = .noSelection

  /// Minutes from midnight.
  var time1: Int32 = 0

  /// Minutes from midnight.
  var time2: Int32 = 0

  /// Minutes from midnight.
  var time3: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Selection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noSelection // = 0
    case time1 // = 1
    case time2 // = 2
    case time3 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .noSelection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noSelection
      case 1: self = .time1
      case 2: self = .time2
      case 3: self = .time3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noSelection: return 0
      case .time1: return 1
      case .time2: return 2
      case .time3: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_AuxheatConfigure.Selection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_AuxheatConfigure.Selection] = [
    .noSelection,
    .time1,
    .time2,
    .time3,
  ]
}

#endif  // swift(>=4.2)

struct Proto_DoorsLock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_DoorsUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofLift {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String {
    get {return _storage._pin}
    set {_uniqueStorage()._pin = newValue}
  }

  var sunroof: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sunroof ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sunroof = newValue}
  }
  /// Returns true if `sunroof` has been explicitly set.
  var hasSunroof: Bool {return _storage._sunroof != nil}
  /// Clears the value of `sunroof`. Subsequent reads from it will return its default value.
  mutating func clearSunroof() {_uniqueStorage()._sunroof = nil}

  var sunroofBlindFront: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sunroofBlindFront ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sunroofBlindFront = newValue}
  }
  /// Returns true if `sunroofBlindFront` has been explicitly set.
  var hasSunroofBlindFront: Bool {return _storage._sunroofBlindFront != nil}
  /// Clears the value of `sunroofBlindFront`. Subsequent reads from it will return its default value.
  mutating func clearSunroofBlindFront() {_uniqueStorage()._sunroofBlindFront = nil}

  var sunroofBlindRear: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sunroofBlindRear ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sunroofBlindRear = newValue}
  }
  /// Returns true if `sunroofBlindRear` has been explicitly set.
  var hasSunroofBlindRear: Bool {return _storage._sunroofBlindRear != nil}
  /// Clears the value of `sunroofBlindRear`. Subsequent reads from it will return its default value.
  mutating func clearSunroofBlindRear() {_uniqueStorage()._sunroofBlindRear = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_WindowsOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsVentilate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String {
    get {return _storage._pin}
    set {_uniqueStorage()._pin = newValue}
  }

  var frontLeft: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._frontLeft ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._frontLeft = newValue}
  }
  /// Returns true if `frontLeft` has been explicitly set.
  var hasFrontLeft: Bool {return _storage._frontLeft != nil}
  /// Clears the value of `frontLeft`. Subsequent reads from it will return its default value.
  mutating func clearFrontLeft() {_uniqueStorage()._frontLeft = nil}

  var frontRight: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._frontRight ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._frontRight = newValue}
  }
  /// Returns true if `frontRight` has been explicitly set.
  var hasFrontRight: Bool {return _storage._frontRight != nil}
  /// Clears the value of `frontRight`. Subsequent reads from it will return its default value.
  mutating func clearFrontRight() {_uniqueStorage()._frontRight = nil}

  var rearBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rearBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rearBlind = newValue}
  }
  /// Returns true if `rearBlind` has been explicitly set.
  var hasRearBlind: Bool {return _storage._rearBlind != nil}
  /// Clears the value of `rearBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearBlind() {_uniqueStorage()._rearBlind = nil}

  var rearLeft: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rearLeft ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rearLeft = newValue}
  }
  /// Returns true if `rearLeft` has been explicitly set.
  var hasRearLeft: Bool {return _storage._rearLeft != nil}
  /// Clears the value of `rearLeft`. Subsequent reads from it will return its default value.
  mutating func clearRearLeft() {_uniqueStorage()._rearLeft = nil}

  var rearLeftBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rearLeftBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rearLeftBlind = newValue}
  }
  /// Returns true if `rearLeftBlind` has been explicitly set.
  var hasRearLeftBlind: Bool {return _storage._rearLeftBlind != nil}
  /// Clears the value of `rearLeftBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearLeftBlind() {_uniqueStorage()._rearLeftBlind = nil}

  var rearRight: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rearRight ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rearRight = newValue}
  }
  /// Returns true if `rearRight` has been explicitly set.
  var hasRearRight: Bool {return _storage._rearRight != nil}
  /// Clears the value of `rearRight`. Subsequent reads from it will return its default value.
  mutating func clearRearRight() {_uniqueStorage()._rearRight = nil}

  var rearRightBlind: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rearRightBlind ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rearRightBlind = newValue}
  }
  /// Returns true if `rearRightBlind` has been explicitly set.
  var hasRearRightBlind: Bool {return _storage._rearRightBlind != nil}
  /// Clears the value of `rearRightBlind`. Subsequent reads from it will return its default value.
  mutating func clearRearRightBlind() {_uniqueStorage()._rearRightBlind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_SpeedalertStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var threshold: Int32 = 0

  var alertEndTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedalertStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTime: Int32 = 0

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure preconditioning
struct Proto_ZEVPreconditioningConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTimeMode: Proto_ZEVPreconditioningConfigure.DepartureTimeMode = .disabled

  var departureTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DepartureTimeMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled // = 0
    case singleDeparture // = 1
    case weeklyDeparture // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .singleDeparture
      case 2: self = .weeklyDeparture
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .singleDeparture: return 1
      case .weeklyDeparture: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningConfigure.DepartureTimeMode] = [
    .disabled,
    .singleDeparture,
    .weeklyDeparture,
  ]
}

#endif  // swift(>=4.2)

/// Configure which seats should be preconditioned.
/// Currently, the only available options are to precondition all seats or only the front-left seat
struct Proto_ZEVPreconditioningConfigureSeats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontLeft: Bool = false

  var frontRight: Bool = false

  var rearLeft: Bool = false

  var rearRight: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure the charge program
struct Proto_BatteryChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_BatteryChargeProgramConfigure.ChargeProgram = .default

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case instant // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .instant
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .instant: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_BatteryChargeProgramConfigure.ChargeProgram] = [
    .default,
    .instant,
  ]
}

#endif  // swift(>=4.2)

/// Configure the maximum value for the state of charge of the HV battery
struct Proto_BatteryMaxSocConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values need to be between 50 and 100 and divisible by ten
  var maxSoc: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Select the given charge program and enables the consumer to configure it.
struct Proto_ChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_ChargeProgramConfigure.ChargeProgram {
    get {return _storage._chargeProgram}
    set {_uniqueStorage()._chargeProgram = newValue}
  }

  /// Values need to be between 50 and 100 and divisible by ten
  /// Maximum value for the state of charge of the HV battery [in %].
  /// Valid value range = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
  var maxSoc: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._maxSoc ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._maxSoc = newValue}
  }
  /// Returns true if `maxSoc` has been explicitly set.
  var hasMaxSoc: Bool {return _storage._maxSoc != nil}
  /// Clears the value of `maxSoc`. Subsequent reads from it will return its default value.
  mutating func clearMaxSoc() {_uniqueStorage()._maxSoc = nil}

  /// unlock the plug after charging is finished
  /// Denotes whether the charge cable should be unlocked automatically if the HV battery is fully charged resp. charged til Max. SoC value.
  /// true - unlock automatically, false - do not unlock automatically
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var autoUnlock: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._autoUnlock ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._autoUnlock = newValue}
  }
  /// Returns true if `autoUnlock` has been explicitly set.
  var hasAutoUnlock: Bool {return _storage._autoUnlock != nil}
  /// Clears the value of `autoUnlock`. Subsequent reads from it will return its default value.
  mutating func clearAutoUnlock() {_uniqueStorage()._autoUnlock = nil}

  /// automatically switch between home and work program, based on the location of the car
  /// Denotes whether location based charging should be used.
  /// true - use location based charging, false - do not use location based charging
  /// can only be used if chargeprogram is set to home or work. Otherwise it will be ignored.
  var locationBasedCharging: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._locationBasedCharging ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._locationBasedCharging = newValue}
  }
  /// Returns true if `locationBasedCharging` has been explicitly set.
  var hasLocationBasedCharging: Bool {return _storage._locationBasedCharging != nil}
  /// Clears the value of `locationBasedCharging`. Subsequent reads from it will return its default value.
  mutating func clearLocationBasedCharging() {_uniqueStorage()._locationBasedCharging = nil}

  /// enable or disable clocktimer
  var clockTimer: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._clockTimer ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._clockTimer = newValue}
  }
  /// Returns true if `clockTimer` has been explicitly set.
  var hasClockTimer: Bool {return _storage._clockTimer != nil}
  /// Clears the value of `clockTimer`. Subsequent reads from it will return its default value.
  mutating func clearClockTimer() {_uniqueStorage()._clockTimer = nil}

  /// enable or disable ecocharging
  var ecoCharging: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._ecoCharging ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._ecoCharging = newValue}
  }
  /// Returns true if `ecoCharging` has been explicitly set.
  var hasEcoCharging: Bool {return _storage._ecoCharging != nil}
  /// Clears the value of `ecoCharging`. Subsequent reads from it will return its default value.
  mutating func clearEcoCharging() {_uniqueStorage()._ecoCharging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case defaultChargeProgram // = 0

    /// Instant charge program should not be used
    /// INSTANT_CHARGE_PROGRAM = 1;
    case homeChargeProgram // = 2
    case workChargeProgram // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .defaultChargeProgram
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defaultChargeProgram
      case 2: self = .homeChargeProgram
      case 3: self = .workChargeProgram
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .defaultChargeProgram: return 0
      case .homeChargeProgram: return 2
      case .workChargeProgram: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Proto_ChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargeProgramConfigure.ChargeProgram] = [
    .defaultChargeProgram,
    .homeChargeProgram,
    .workChargeProgram,
  ]
}

#endif  // swift(>=4.2)

/// This is an experimental command
struct Proto_ChargeControlConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enables/Disables bidrectional charging
  var biChargingEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._biChargingEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._biChargingEnabled = newValue}
  }
  /// Returns true if `biChargingEnabled` has been explicitly set.
  var hasBiChargingEnabled: Bool {return _storage._biChargingEnabled != nil}
  /// Clears the value of `biChargingEnabled`. Subsequent reads from it will return its default value.
  mutating func clearBiChargingEnabled() {_uniqueStorage()._biChargingEnabled = nil}

  /// Sets the charging power in kW with a resolution of 0.1 kW. The value has an offset of -100 kW. So
  /// a value of 0 is equivalent to -100 kW.
  var chargingPower: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _storage._chargingPower ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_uniqueStorage()._chargingPower = newValue}
  }
  /// Returns true if `chargingPower` has been explicitly set.
  var hasChargingPower: Bool {return _storage._chargingPower != nil}
  /// Clears the value of `chargingPower`. Subsequent reads from it will return its default value.
  mutating func clearChargingPower() {_uniqueStorage()._chargingPower = nil}

  /// must not be above max_soc
  var minSoc: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._minSoc ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._minSoc = newValue}
  }
  /// Returns true if `minSoc` has been explicitly set.
  var hasMinSoc: Bool {return _storage._minSoc != nil}
  /// Clears the value of `minSoc`. Subsequent reads from it will return its default value.
  mutating func clearMinSoc() {_uniqueStorage()._minSoc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Provide functionality to initiate a charge optimization configuration
struct Proto_ChargeOptConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weekdayTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var weekendTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tariff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rate: Proto_ChargeOptConfigure.Tariff.Rate = .invalidPrice

    /// Time in seconds after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Rate: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case invalidPrice // = 0
      case lowPrice // = 33
      case normalPrice // = 44
      case highPrice // = 66
      case UNRECOGNIZED(Int)

      init() {
        self = .invalidPrice
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .invalidPrice
        case 33: self = .lowPrice
        case 44: self = .normalPrice
        case 66: self = .highPrice
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .invalidPrice: return 0
        case .lowPrice: return 33
        case .normalPrice: return 44
        case .highPrice: return 66
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Provide the functionality to start the charge optimization function in the vehicle
struct Proto_ChargeOptStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to stop the charge optimization function in the vehicle
struct Proto_ChargeOptStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set the temperature points of the vehicle
struct Proto_TemperatureConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var temperaturePoints: [Proto_TemperatureConfigure.TemperaturePoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TemperaturePoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var zone: Proto_TemperatureConfigure.TemperaturePoint.Zone = .unknown

    var temperatureInCelsius: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Zone: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
      /// enum values to be used in code.
      /// These definitions need to come before upper case versions
      case unknown // = 0
      case frontLeft // = 1
      case frontRight // = 2
      case frontCenter // = 3
      case rearLeft // = 4
      case rearRight // = 5
      case rearCenter // = 6
      case rear2Left // = 7
      case rear2Right // = 8

      /// PLEASE BE AWARE OF THE FOLLOWING BEFORE ADDING NEW ZONES:
      /// Currently there is a bug in vehicle API, that we need to send the zones in the correct order. Otherwise the request will be rejected.
      /// The order needs to be like the following:
      /// Front before rear before rear2
      /// Left before right - There is no center zone if there are left and right zones in this row
      /// As this is already the order like specified here, this needs to be considered on adding new zones.
      case rear2Center // = 9
      static let unknownZone = unknown
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .frontLeft
        case 2: self = .frontRight
        case 3: self = .frontCenter
        case 4: self = .rearLeft
        case 5: self = .rearRight
        case 6: self = .rearCenter
        case 7: self = .rear2Left
        case 8: self = .rear2Right
        case 9: self = .rear2Center
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .frontLeft: return 1
        case .frontRight: return 2
        case .frontCenter: return 3
        case .rearLeft: return 4
        case .rearRight: return 5
        case .rearCenter: return 6
        case .rear2Left: return 7
        case .rear2Right: return 8
        case .rear2Center: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Set the weekprofile for the weekly departure time settings
struct Proto_WeekProfileConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weeklySetHu: [Proto_WeekProfileConfigure.WeeklySetHU] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WeeklySetHU {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var day: Proto_WeekProfileConfigure.WeeklySetHU.Day = .monday

    /// Time in minutes after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Day: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case monday // = 0
      case tuesday // = 1
      case wednesday // = 2
      case thursday // = 3
      case friday // = 4
      case saturday // = 5
      case sunday // = 6
      case UNRECOGNIZED(Int)

      init() {
        self = .monday
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .monday
        case 1: self = .tuesday
        case 2: self = .wednesday
        case 3: self = .thursday
        case 4: self = .friday
        case 5: self = .saturday
        case 6: self = .sunday
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .monday: return 0
        case .tuesday: return 1
        case .wednesday: return 2
        case .thursday: return 3
        case .friday: return 4
        case .saturday: return 5
        case .sunday: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Set the week profile for the weekly departure time settings version 2
struct Proto_WeekProfileConfigureV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// * The whole list of timeProfiles must always be provided
  var timeProfiles: [Proto_TimeProfile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_TimeProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///=> only if time profile entry is unchanged, do not provide attribute "id" if new profile entry shall be added
  ///   If a new time profile shall be added: do not provide the ID => ID will be set by MIC / vehicle
  var identifier: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._identifier ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return _storage._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {_uniqueStorage()._identifier = nil}

  /// Hour after midnight range [0, 23]
  var hour: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._hour ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._hour = newValue}
  }
  /// Returns true if `hour` has been explicitly set.
  var hasHour: Bool {return _storage._hour != nil}
  /// Clears the value of `hour`. Subsequent reads from it will return its default value.
  mutating func clearHour() {_uniqueStorage()._hour = nil}

  /// Minute after full hour range [0, 59]
  var minute: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._minute ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._minute = newValue}
  }
  /// Returns true if `minute` has been explicitly set.
  var hasMinute: Bool {return _storage._minute != nil}
  /// Clears the value of `minute`. Subsequent reads from it will return its default value.
  mutating func clearMinute() {_uniqueStorage()._minute = nil}

  /// Days for which the above time should be applied
  var days: [Proto_TimeProfileDay] {
    get {return _storage._days}
    set {_uniqueStorage()._days = newValue}
  }

  /// Whether this profile entry is active or not
  var active: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._active ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {_uniqueStorage()._active = nil}

  /// If a timeProfile is changed or added the respective applicationId must be provided by the SDK
  ///   11 = Internal Apps
  ///   12 = External Apps
  var applicationIdentifier: Int32 {
    get {return _storage._applicationIdentifier}
    set {_uniqueStorage()._applicationIdentifier = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Invoke the Remote Vehicle Finder for signalling the vehicle’s position with lights, horn or panic alarm.
struct Proto_SigPosStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value needs to be between 0 and 30. The default is 0.
  /// Only allowed for RAMSES
  var hornRepeat: Int32 = 0

  var hornType: Proto_SigPosStart.HornType = .hornOff

  var lightType: Proto_SigPosStart.LightType = .lightOff

  /// Value needs to be between 0 and 10. It indicates how long the light should be switched on.
  var sigposDuration: Int32 = 0

  var sigposType: Proto_SigPosStart.SigposType = .lightOnly

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Only allowed for RAMSES
  enum HornType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case hornOff // = 0
    case hornLowVolume // = 1
    case hornHighVolume // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .hornOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hornOff
      case 1: self = .hornLowVolume
      case 2: self = .hornHighVolume
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hornOff: return 0
      case .hornLowVolume: return 1
      case .hornHighVolume: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Only allowed for RAMSES
  enum LightType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOff // = 0
    case dippedHeadLight // = 1
    case warningLight // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOff
      case 1: self = .dippedHeadLight
      case 2: self = .warningLight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOff: return 0
      case .dippedHeadLight: return 1
      case .warningLight: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum SigposType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOnly // = 0

    /// Only allowed for RAMSES
    case hornOnly // = 1

    /// Only allowed for RAMSES
    case lightAndHorn // = 2

    /// Only allowed for HERMES
    case panicAlarm // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOnly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOnly
      case 1: self = .hornOnly
      case 2: self = .lightAndHorn
      case 3: self = .panicAlarm
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOnly: return 0
      case .hornOnly: return 1
      case .lightAndHorn: return 2
      case .panicAlarm: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_SigPosStart.HornType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.HornType] = [
    .hornOff,
    .hornLowVolume,
    .hornHighVolume,
  ]
}

extension Proto_SigPosStart.LightType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.LightType] = [
    .lightOff,
    .dippedHeadLight,
    .warningLight,
  ]
}

extension Proto_SigPosStart.SigposType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.SigposType] = [
    .lightOnly,
    .hornOnly,
    .lightAndHorn,
    .panicAlarm,
  ]
}

#endif  // swift(>=4.2)

/// Confirm the detected parking bump
struct Proto_TheftalarmConfirmDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the parking damage detection sensor
struct Proto_TheftalarmDeselectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the interior protection sensor
struct Proto_TheftalarmDeselectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the tow protection sensor
struct Proto_TheftalarmDeselectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the parking damage detection sensor
struct Proto_TheftalarmSelectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the interior protection sensor
struct Proto_TheftalarmSelectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the tow protection sensor
struct Proto_TheftalarmSelectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to trigger an alarm that lasts for "alarm_duration" seconds
struct Proto_TheftalarmStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify how many seconds the alarm should be switched on
  var alarmDurationInSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deactivate an active/ongoing alarm
struct Proto_TheftalarmStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AutomaticValetParkingActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bookingID: String = String()

  var driveType: Proto_DriveType = .unknownDriveType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeFlapUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChargeCouplerUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Door: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_door", aliases: ["UNKNOWN_DOOR"]),
    1: .aliased(proto: "frontleft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontright", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "rearleft", aliases: ["REAR_LEFT"]),
    4: .aliased(proto: "rearright", aliases: ["REAR_RIGHT"]),
    5: .aliased(proto: "trunk", aliases: ["TRUNK"]),
    6: .aliased(proto: "fuelflap", aliases: ["FUEL_FLAP"]),
    7: .aliased(proto: "chargeflap", aliases: ["CHARGE_FLAP"]),
    8: .aliased(proto: "chargecoupler", aliases: ["CHARGE_COUPLER"]),
  ]
}

extension Proto_ZEVPreconditioningType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_zev_preconditioning_command_type", aliases: ["UNKNOWN_ZEV_PRECONDITIONING_COMMAND_TYPE"]),
    1: .aliased(proto: "immediate", aliases: ["IMMEDIATE"]),
    2: .aliased(proto: "departure", aliases: ["DEPARTURE"]),
    3: .aliased(proto: "now", aliases: ["NOW"]),
    4: .aliased(proto: "departureWeekly", aliases: ["DEPARTURE_WEEKLY"]),
  ]
}

extension Proto_TimeProfileDay: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "Mo", aliases: ["MONDAY"]),
    1: .aliased(proto: "Tu", aliases: ["TUESDAY"]),
    2: .aliased(proto: "We", aliases: ["WEDNESDAY"]),
    3: .aliased(proto: "Th", aliases: ["THURSDAY"]),
    4: .aliased(proto: "Fr", aliases: ["FRIDAY"]),
    5: .aliased(proto: "Sa", aliases: ["SATURDAY"]),
    6: .aliased(proto: "Su", aliases: ["SUNDAY"]),
  ]
}

extension Proto_DriveType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DRIVE_TYPE"),
    1: .same(proto: "PICK_UP"),
    2: .same(proto: "DROP_OFF"),
  ]
}

extension Proto_AcknowledgeCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.requestID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeCommandRequest, rhs: Proto_AcknowledgeCommandRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vin"),
    7: .standard(proto: "request_id"),
    36: .same(proto: "backend"),
    2: .standard(proto: "auxheat_start"),
    3: .standard(proto: "auxheat_stop"),
    4: .standard(proto: "auxheat_configure"),
    5: .standard(proto: "doors_lock"),
    6: .standard(proto: "doors_unlock"),
    9: .standard(proto: "sunroof_open"),
    10: .standard(proto: "sunroof_close"),
    11: .standard(proto: "sunroof_lift"),
    47: .standard(proto: "sunroof_move"),
    12: .standard(proto: "windows_open"),
    13: .standard(proto: "windows_close"),
    43: .standard(proto: "windows_ventilate"),
    44: .standard(proto: "windows_move"),
    19: .standard(proto: "engine_start"),
    20: .standard(proto: "engine_stop"),
    21: .standard(proto: "zev_preconditioning_start"),
    22: .standard(proto: "zev_preconditioning_stop"),
    25: .standard(proto: "zev_precondition_configure"),
    26: .standard(proto: "zev_precondition_configure_seats"),
    23: .standard(proto: "speedalert_start"),
    24: .standard(proto: "speedalert_stop"),
    27: .standard(proto: "battery_charge_program"),
    28: .standard(proto: "battery_max_soc"),
    34: .standard(proto: "charge_program_configure"),
    40: .standard(proto: "charge_control_configure"),
    29: .standard(proto: "charge_opt_configure"),
    30: .standard(proto: "charge_opt_start"),
    31: .standard(proto: "charge_opt_stop"),
    32: .standard(proto: "temperature_configure"),
    33: .standard(proto: "week_profile_configure"),
    41: .standard(proto: "week_profile_configure_v2"),
    35: .standard(proto: "sigpos_start"),
    8: .standard(proto: "theftalarm_confirm_damagedetection"),
    14: .standard(proto: "theftalarm_deselect_damagedetection"),
    15: .standard(proto: "theftalarm_deselect_interior"),
    16: .standard(proto: "theftalarm_deselect_tow"),
    17: .standard(proto: "theftalarm_select_damagedetection"),
    18: .standard(proto: "theftalarm_select_interior"),
    37: .standard(proto: "theftalarm_select_tow"),
    38: .standard(proto: "theftalarm_start"),
    39: .standard(proto: "theftalarm_stop"),
    42: .standard(proto: "automatic_valet_parking_activate"),
    45: .standard(proto: "charge_flap_unlock"),
    46: .standard(proto: "charge_coupler_unlock"),
    48: .standard(proto: "deactivate_vehicle_keys"),
    49: .standard(proto: "activate_vehicle_keys"),
  ]

  fileprivate class _StorageClass {
    var _vin: String = String()
    var _requestID: String = String()
    var _backend: Proto_CommandRequest.Backend = .vva
    var _command: Proto_CommandRequest.OneOf_Command?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vin = source._vin
      _requestID = source._requestID
      _backend = source._backend
      _command = source._command
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._vin)
        case 2:
          var v: Proto_AuxheatStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatStart(v)}
        case 3:
          var v: Proto_AuxheatStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatStop(v)}
        case 4:
          var v: Proto_AuxheatConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatConfigure(v)}
        case 5:
          var v: Proto_DoorsLock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .doorsLock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .doorsLock(v)}
        case 6:
          var v: Proto_DoorsUnlock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .doorsUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .doorsUnlock(v)}
        case 7: try decoder.decodeSingularStringField(value: &_storage._requestID)
        case 8:
          var v: Proto_TheftalarmConfirmDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmConfirmDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmConfirmDamagedetection(v)}
        case 9:
          var v: Proto_SunroofOpen?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofOpen(v)}
        case 10:
          var v: Proto_SunroofClose?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofClose(v)}
        case 11:
          var v: Proto_SunroofLift?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofLift(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofLift(v)}
        case 12:
          var v: Proto_WindowsOpen?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsOpen(v)}
        case 13:
          var v: Proto_WindowsClose?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsClose(v)}
        case 14:
          var v: Proto_TheftalarmDeselectDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectDamagedetection(v)}
        case 15:
          var v: Proto_TheftalarmDeselectInterior?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectInterior(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectInterior(v)}
        case 16:
          var v: Proto_TheftalarmDeselectTow?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectTow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectTow(v)}
        case 17:
          var v: Proto_TheftalarmSelectDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectDamagedetection(v)}
        case 18:
          var v: Proto_TheftalarmSelectInterior?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectInterior(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectInterior(v)}
        case 19:
          var v: Proto_EngineStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .engineStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .engineStart(v)}
        case 20:
          var v: Proto_EngineStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .engineStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .engineStop(v)}
        case 21:
          var v: Proto_ZEVPreconditioningStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditioningStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditioningStart(v)}
        case 22:
          var v: Proto_ZEVPreconditioningStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditioningStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditioningStop(v)}
        case 23:
          var v: Proto_SpeedalertStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .speedalertStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .speedalertStart(v)}
        case 24:
          var v: Proto_SpeedalertStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .speedalertStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .speedalertStop(v)}
        case 25:
          var v: Proto_ZEVPreconditioningConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditionConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditionConfigure(v)}
        case 26:
          var v: Proto_ZEVPreconditioningConfigureSeats?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditionConfigureSeats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditionConfigureSeats(v)}
        case 27:
          var v: Proto_BatteryChargeProgramConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .batteryChargeProgram(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .batteryChargeProgram(v)}
        case 28:
          var v: Proto_BatteryMaxSocConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .batteryMaxSoc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .batteryMaxSoc(v)}
        case 29:
          var v: Proto_ChargeOptConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptConfigure(v)}
        case 30:
          var v: Proto_ChargeOptStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptStart(v)}
        case 31:
          var v: Proto_ChargeOptStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptStop(v)}
        case 32:
          var v: Proto_TemperatureConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .temperatureConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .temperatureConfigure(v)}
        case 33:
          var v: Proto_WeekProfileConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .weekProfileConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .weekProfileConfigure(v)}
        case 34:
          var v: Proto_ChargeProgramConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeProgramConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeProgramConfigure(v)}
        case 35:
          var v: Proto_SigPosStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sigposStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sigposStart(v)}
        case 36: try decoder.decodeSingularEnumField(value: &_storage._backend)
        case 37:
          var v: Proto_TheftalarmSelectTow?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectTow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectTow(v)}
        case 38:
          var v: Proto_TheftalarmStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmStart(v)}
        case 39:
          var v: Proto_TheftalarmStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmStop(v)}
        case 40:
          var v: Proto_ChargeControlConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeControlConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeControlConfigure(v)}
        case 41:
          var v: Proto_WeekProfileConfigureV2?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .weekProfileConfigureV2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .weekProfileConfigureV2(v)}
        case 42:
          var v: Proto_AutomaticValetParkingActivate?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .automaticValetParkingActivate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .automaticValetParkingActivate(v)}
        case 43:
          var v: Proto_WindowsVentilate?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsVentilate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsVentilate(v)}
        case 44:
          var v: Proto_WindowsMove?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsMove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsMove(v)}
        case 45:
          var v: Proto_ChargeFlapUnlock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeFlapUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeFlapUnlock(v)}
        case 46:
          var v: Proto_ChargeCouplerUnlock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeCouplerUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeCouplerUnlock(v)}
        case 47:
          var v: Proto_SunroofMove?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofMove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofMove(v)}
        case 48:
          var v: Proto_DeactivateVehicleKeys?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .deactivateVehicleKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .deactivateVehicleKeys(v)}
        case 49:
          var v: Proto_ActivateVehicleKeys?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .activateVehicleKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .activateVehicleKeys(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._vin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vin, fieldNumber: 1)
      }
      switch _storage._command {
      case .auxheatStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .auxheatStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .auxheatConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .doorsLock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .doorsUnlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      default: break
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 7)
      }
      switch _storage._command {
      case .theftalarmConfirmDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .sunroofOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .sunroofClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .sunroofLift(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .windowsOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .windowsClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .theftalarmDeselectDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .theftalarmDeselectInterior(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .theftalarmDeselectTow(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .theftalarmSelectDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .theftalarmSelectInterior(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .engineStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .engineStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .zevPreconditioningStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .zevPreconditioningStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .speedalertStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .speedalertStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .zevPreconditionConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .zevPreconditionConfigureSeats(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .batteryChargeProgram(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .batteryMaxSoc(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .chargeOptConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .chargeOptStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .chargeOptStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .temperatureConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .weekProfileConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      case .chargeProgramConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      case .sigposStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      case nil: break
      default: break
      }
      if _storage._backend != .vva {
        try visitor.visitSingularEnumField(value: _storage._backend, fieldNumber: 36)
      }
      switch _storage._command {
      case .theftalarmSelectTow(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      case .theftalarmStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      case .theftalarmStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      case .chargeControlConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .weekProfileConfigureV2(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .automaticValetParkingActivate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      case .windowsVentilate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      case .windowsMove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      case .chargeFlapUnlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      case .chargeCouplerUnlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      case .sunroofMove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      case .deactivateVehicleKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      case .activateVehicleKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandRequest, rhs: Proto_CommandRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vin != rhs_storage._vin {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._backend != rhs_storage._backend {return false}
        if _storage._command != rhs_storage._command {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest.Backend: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VVA"),
    1: .same(proto: "VehicleAPI"),
  ]
}

extension Proto_DeactivateVehicleKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeactivateVehicleKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .standard(proto: "expiration_unix"),
    3: .standard(proto: "expiration_seconds"),
    4: .standard(proto: "expiration_milliseconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expirationUnix)
      case 3: try decoder.decodeSingularStringField(value: &self.expirationSeconds)
      case 4: try decoder.decodeSingularStringField(value: &self.expirationMilliseconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if self.expirationUnix != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationUnix, fieldNumber: 2)
    }
    if !self.expirationSeconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationSeconds, fieldNumber: 3)
    }
    if !self.expirationMilliseconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationMilliseconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeactivateVehicleKeys, rhs: Proto_DeactivateVehicleKeys) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.expirationUnix != rhs.expirationUnix {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.expirationMilliseconds != rhs.expirationMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ActivateVehicleKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateVehicleKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .standard(proto: "expiration_unix"),
    3: .standard(proto: "expiration_seconds"),
    4: .standard(proto: "expiration_milliseconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expirationUnix)
      case 3: try decoder.decodeSingularStringField(value: &self.expirationSeconds)
      case 4: try decoder.decodeSingularStringField(value: &self.expirationMilliseconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if self.expirationUnix != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationUnix, fieldNumber: 2)
    }
    if !self.expirationSeconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationSeconds, fieldNumber: 3)
    }
    if !self.expirationMilliseconds.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationMilliseconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ActivateVehicleKeys, rhs: Proto_ActivateVehicleKeys) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.expirationUnix != rhs.expirationUnix {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.expirationMilliseconds != rhs.expirationMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStart, rhs: Proto_AuxheatStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStop, rhs: Proto_AuxheatStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "time_selection", json: "auxheattimeselection"),
    2: .unique(proto: "time_1", json: "auxheattime1"),
    3: .unique(proto: "time_2", json: "auxheattime2"),
    4: .unique(proto: "time_3", json: "auxheattime3"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.timeSelection)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time1)
      case 3: try decoder.decodeSingularInt32Field(value: &self.time2)
      case 4: try decoder.decodeSingularInt32Field(value: &self.time3)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeSelection != .noSelection {
      try visitor.visitSingularEnumField(value: self.timeSelection, fieldNumber: 1)
    }
    if self.time1 != 0 {
      try visitor.visitSingularInt32Field(value: self.time1, fieldNumber: 2)
    }
    if self.time2 != 0 {
      try visitor.visitSingularInt32Field(value: self.time2, fieldNumber: 3)
    }
    if self.time3 != 0 {
      try visitor.visitSingularInt32Field(value: self.time3, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatConfigure, rhs: Proto_AuxheatConfigure) -> Bool {
    if lhs.timeSelection != rhs.timeSelection {return false}
    if lhs.time1 != rhs.time1 {return false}
    if lhs.time2 != rhs.time2 {return false}
    if lhs.time3 != rhs.time3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure.Selection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_SELECTION"),
    1: .same(proto: "TIME_1"),
    2: .same(proto: "TIME_2"),
    3: .same(proto: "TIME_3"),
  ]
}

extension Proto_DoorsLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.doors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsLock, rhs: Proto_DoorsLock) -> Bool {
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DoorsUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsUnlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.doors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsUnlock, rhs: Proto_DoorsUnlock) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStart, rhs: Proto_EngineStart) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStop, rhs: Proto_EngineStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofOpen, rhs: Proto_SunroofOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofClose, rhs: Proto_SunroofClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofLift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofLift"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofLift, rhs: Proto_SunroofLift) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "sunroof"),
    3: .unique(proto: "sunroof_blind_front", json: "sunroofblindfront"),
    4: .unique(proto: "sunroof_blind_rear", json: "sunroofblindrear"),
  ]

  fileprivate class _StorageClass {
    var _pin: String = String()
    var _sunroof: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sunroofBlindFront: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sunroofBlindRear: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pin = source._pin
      _sunroof = source._sunroof
      _sunroofBlindFront = source._sunroofBlindFront
      _sunroofBlindRear = source._sunroofBlindRear
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._pin)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sunroof)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._sunroofBlindFront)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._sunroofBlindRear)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._pin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pin, fieldNumber: 1)
      }
      if let v = _storage._sunroof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._sunroofBlindFront {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._sunroofBlindRear {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofMove, rhs: Proto_SunroofMove) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pin != rhs_storage._pin {return false}
        if _storage._sunroof != rhs_storage._sunroof {return false}
        if _storage._sunroofBlindFront != rhs_storage._sunroofBlindFront {return false}
        if _storage._sunroofBlindRear != rhs_storage._sunroofBlindRear {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsOpen, rhs: Proto_WindowsOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsClose, rhs: Proto_WindowsClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsVentilate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsVentilate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsVentilate, rhs: Proto_WindowsVentilate) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .unique(proto: "front_left", json: "windowfrontleft"),
    3: .unique(proto: "front_right", json: "windowfrontright"),
    4: .unique(proto: "rear_blind", json: "windowrearblind"),
    5: .unique(proto: "rear_left", json: "windowrearleft"),
    6: .unique(proto: "rear_left_blind", json: "windowrearleftblind"),
    7: .unique(proto: "rear_right", json: "windowrearright"),
    8: .unique(proto: "rear_right_blind", json: "windowrearrightblind"),
  ]

  fileprivate class _StorageClass {
    var _pin: String = String()
    var _frontLeft: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _frontRight: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rearBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rearLeft: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rearLeftBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rearRight: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rearRightBlind: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pin = source._pin
      _frontLeft = source._frontLeft
      _frontRight = source._frontRight
      _rearBlind = source._rearBlind
      _rearLeft = source._rearLeft
      _rearLeftBlind = source._rearLeftBlind
      _rearRight = source._rearRight
      _rearRightBlind = source._rearRightBlind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._pin)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._frontLeft)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._frontRight)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._rearBlind)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._rearLeft)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._rearLeftBlind)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._rearRight)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._rearRightBlind)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._pin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pin, fieldNumber: 1)
      }
      if let v = _storage._frontLeft {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._frontRight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._rearBlind {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._rearLeft {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._rearLeftBlind {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._rearRight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._rearRightBlind {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsMove, rhs: Proto_WindowsMove) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pin != rhs_storage._pin {return false}
        if _storage._frontLeft != rhs_storage._frontLeft {return false}
        if _storage._frontRight != rhs_storage._frontRight {return false}
        if _storage._rearBlind != rhs_storage._rearBlind {return false}
        if _storage._rearLeft != rhs_storage._rearLeft {return false}
        if _storage._rearLeftBlind != rhs_storage._rearLeftBlind {return false}
        if _storage._rearRight != rhs_storage._rearRight {return false}
        if _storage._rearRightBlind != rhs_storage._rearRightBlind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "threshold", json: "speedAlertThreshold"),
    2: .unique(proto: "alert_end_time", json: "speedAlertEndTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.threshold)
      case 2: try decoder.decodeSingularInt64Field(value: &self.alertEndTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularInt32Field(value: self.threshold, fieldNumber: 1)
    }
    if self.alertEndTime != 0 {
      try visitor.visitSingularInt64Field(value: self.alertEndTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStart, rhs: Proto_SpeedalertStart) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.alertEndTime != rhs.alertEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStop, rhs: Proto_SpeedalertStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "departure_time", json: "departuretime"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.departureTime)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 1)
    }
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStart, rhs: Proto_ZEVPreconditioningStart) -> Bool {
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStop, rhs: Proto_ZEVPreconditioningStop) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "departure_time_mode"),
    3: .unique(proto: "departure_time", json: "departuretime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.departureTimeMode)
      case 3: try decoder.decodeSingularInt32Field(value: &self.departureTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTimeMode != .disabled {
      try visitor.visitSingularEnumField(value: self.departureTimeMode, fieldNumber: 1)
    }
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigure, rhs: Proto_ZEVPreconditioningConfigure) -> Bool {
    if lhs.departureTimeMode != rhs.departureTimeMode {return false}
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "SINGLE_DEPARTURE"),
    2: .same(proto: "WEEKLY_DEPARTURE"),
  ]
}

extension Proto_ZEVPreconditioningConfigureSeats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigureSeats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "front_left", json: "precondSeatFrontLeft"),
    2: .unique(proto: "front_right", json: "precondSeatFrontRight"),
    3: .unique(proto: "rear_left", json: "precondSeatRearLeft"),
    4: .unique(proto: "rear_right", json: "precondSeatRearRight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.frontLeft)
      case 2: try decoder.decodeSingularBoolField(value: &self.frontRight)
      case 3: try decoder.decodeSingularBoolField(value: &self.rearLeft)
      case 4: try decoder.decodeSingularBoolField(value: &self.rearRight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontLeft != false {
      try visitor.visitSingularBoolField(value: self.frontLeft, fieldNumber: 1)
    }
    if self.frontRight != false {
      try visitor.visitSingularBoolField(value: self.frontRight, fieldNumber: 2)
    }
    if self.rearLeft != false {
      try visitor.visitSingularBoolField(value: self.rearLeft, fieldNumber: 3)
    }
    if self.rearRight != false {
      try visitor.visitSingularBoolField(value: self.rearRight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigureSeats, rhs: Proto_ZEVPreconditioningConfigureSeats) -> Bool {
    if lhs.frontLeft != rhs.frontLeft {return false}
    if lhs.frontRight != rhs.frontRight {return false}
    if lhs.rearLeft != rhs.rearLeft {return false}
    if lhs.rearRight != rhs.rearRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.chargeProgram)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .default {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryChargeProgramConfigure, rhs: Proto_BatteryChargeProgramConfigure) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "INSTANT"),
  ]
}

extension Proto_BatteryMaxSocConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryMaxSocConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "max_soc", json: "maxsoc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.maxSoc)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSoc != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSoc, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryMaxSocConfigure, rhs: Proto_BatteryMaxSocConfigure) -> Bool {
    if lhs.maxSoc != rhs.maxSoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
    2: .unique(proto: "max_soc", json: "maxsoc"),
    3: .unique(proto: "auto_unlock", json: "autounlock"),
    4: .unique(proto: "location_based_charging", json: "locationbasedcharging"),
    6: .unique(proto: "clock_timer", json: "clocktimer"),
    7: .unique(proto: "eco_charging", json: "ecocharging"),
  ]

  fileprivate class _StorageClass {
    var _chargeProgram: Proto_ChargeProgramConfigure.ChargeProgram = .defaultChargeProgram
    var _maxSoc: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _autoUnlock: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _locationBasedCharging: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _clockTimer: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _ecoCharging: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chargeProgram = source._chargeProgram
      _maxSoc = source._maxSoc
      _autoUnlock = source._autoUnlock
      _locationBasedCharging = source._locationBasedCharging
      _clockTimer = source._clockTimer
      _ecoCharging = source._ecoCharging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._chargeProgram)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._maxSoc)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._autoUnlock)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._locationBasedCharging)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._clockTimer)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._ecoCharging)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._chargeProgram != .defaultChargeProgram {
        try visitor.visitSingularEnumField(value: _storage._chargeProgram, fieldNumber: 1)
      }
      if let v = _storage._maxSoc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._autoUnlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._locationBasedCharging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._clockTimer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._ecoCharging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeProgramConfigure, rhs: Proto_ChargeProgramConfigure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chargeProgram != rhs_storage._chargeProgram {return false}
        if _storage._maxSoc != rhs_storage._maxSoc {return false}
        if _storage._autoUnlock != rhs_storage._autoUnlock {return false}
        if _storage._locationBasedCharging != rhs_storage._locationBasedCharging {return false}
        if _storage._clockTimer != rhs_storage._clockTimer {return false}
        if _storage._ecoCharging != rhs_storage._ecoCharging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_CHARGE_PROGRAM"),
    2: .same(proto: "HOME_CHARGE_PROGRAM"),
    3: .same(proto: "WORK_CHARGE_PROGRAM"),
  ]
}

extension Proto_ChargeControlConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeControlConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "bi_charging_enabled", json: "bidichargingenabled"),
    2: .unique(proto: "charging_power", json: "chargingpower"),
    3: .unique(proto: "min_soc", json: "minsoc"),
  ]

  fileprivate class _StorageClass {
    var _biChargingEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _chargingPower: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    var _minSoc: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _biChargingEnabled = source._biChargingEnabled
      _chargingPower = source._chargingPower
      _minSoc = source._minSoc
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._biChargingEnabled)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chargingPower)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._minSoc)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._biChargingEnabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._chargingPower {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._minSoc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeControlConfigure, rhs: Proto_ChargeControlConfigure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._biChargingEnabled != rhs_storage._biChargingEnabled {return false}
        if _storage._chargingPower != rhs_storage._chargingPower {return false}
        if _storage._minSoc != rhs_storage._minSoc {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekday_tariff", json: "weekdaytariff"),
    2: .unique(proto: "weekend_tariff", json: "weekendtariff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.weekdayTariff)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.weekendTariff)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weekdayTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekdayTariff, fieldNumber: 1)
    }
    if !self.weekendTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekendTariff, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure, rhs: Proto_ChargeOptConfigure) -> Bool {
    if lhs.weekdayTariff != rhs.weekdayTariff {return false}
    if lhs.weekendTariff != rhs.weekendTariff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChargeOptConfigure.protoMessageName + ".Tariff"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.rate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != .invalidPrice {
      try visitor.visitSingularEnumField(value: self.rate, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure.Tariff, rhs: Proto_ChargeOptConfigure.Tariff) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff.Rate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_PRICE"),
    33: .same(proto: "LOW_PRICE"),
    44: .same(proto: "NORMAL_PRICE"),
    66: .same(proto: "HIGH_PRICE"),
  ]
}

extension Proto_ChargeOptStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStart, rhs: Proto_ChargeOptStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStop, rhs: Proto_ChargeOptStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemperatureConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "temperature_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.temperaturePoints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.temperaturePoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.temperaturePoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure, rhs: Proto_TemperatureConfigure) -> Bool {
    if lhs.temperaturePoints != rhs.temperaturePoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_TemperatureConfigure.protoMessageName + ".TemperaturePoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zone"),
    3: .unique(proto: "temperature_in_celsius", json: "temp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.zone)
      case 3: try decoder.decodeSingularDoubleField(value: &self.temperatureInCelsius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.zone != .unknown {
      try visitor.visitSingularEnumField(value: self.zone, fieldNumber: 1)
    }
    if self.temperatureInCelsius != 0 {
      try visitor.visitSingularDoubleField(value: self.temperatureInCelsius, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure.TemperaturePoint, rhs: Proto_TemperatureConfigure.TemperaturePoint) -> Bool {
    if lhs.zone != rhs.zone {return false}
    if lhs.temperatureInCelsius != rhs.temperatureInCelsius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint.Zone: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown", aliases: ["UNKNOWN_ZONE"]),
    1: .aliased(proto: "frontLeft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontRight", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "frontCenter", aliases: ["FRONT_CENTER"]),
    4: .aliased(proto: "rearLeft", aliases: ["REAR_LEFT"]),
    5: .aliased(proto: "rearRight", aliases: ["REAR_RIGHT"]),
    6: .aliased(proto: "rearCenter", aliases: ["REAR_CENTER"]),
    7: .aliased(proto: "rear2Left", aliases: ["REAR_2_LEFT"]),
    8: .aliased(proto: "rear2Right", aliases: ["REAR_2_RIGHT"]),
    9: .aliased(proto: "rear2Center", aliases: ["REAR_2_CENTER"]),
  ]
}

extension Proto_WeekProfileConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekProfileConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekly_set_hu", json: "weeklySetHU"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.weeklySetHu)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weeklySetHu.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weeklySetHu, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure, rhs: Proto_WeekProfileConfigure) -> Bool {
    if lhs.weeklySetHu != rhs.weeklySetHu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_WeekProfileConfigure.protoMessageName + ".WeeklySetHU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.day)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != .monday {
      try visitor.visitSingularEnumField(value: self.day, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure.WeeklySetHU, rhs: Proto_WeekProfileConfigure.WeeklySetHU) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU.Day: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MONDAY"),
    1: .same(proto: "TUESDAY"),
    2: .same(proto: "WEDNESDAY"),
    3: .same(proto: "THURSDAY"),
    4: .same(proto: "FRIDAY"),
    5: .same(proto: "SATURDAY"),
    6: .same(proto: "SUNDAY"),
  ]
}

extension Proto_WeekProfileConfigureV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekProfileConfigureV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "time_profiles", json: "timeprofiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.timeProfiles)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeProfiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigureV2, rhs: Proto_WeekProfileConfigureV2) -> Bool {
    if lhs.timeProfiles != rhs.timeProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TimeProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "identifier", json: "id"),
    2: .same(proto: "hour"),
    3: .unique(proto: "minute", json: "min"),
    4: .unique(proto: "days", json: "day"),
    5: .same(proto: "active"),
    6: .unique(proto: "application_identifier", json: "applicationId"),
  ]

  fileprivate class _StorageClass {
    var _identifier: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _hour: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _minute: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _days: [Proto_TimeProfileDay] = []
    var _active: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _applicationIdentifier: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
      _hour = source._hour
      _minute = source._minute
      _days = source._days
      _active = source._active
      _applicationIdentifier = source._applicationIdentifier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._identifier)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._hour)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._minute)
        case 4: try decoder.decodeRepeatedEnumField(value: &_storage._days)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._active)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._applicationIdentifier)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._identifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._hour {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._minute {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._days.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._days, fieldNumber: 4)
      }
      if let v = _storage._active {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._applicationIdentifier != 0 {
        try visitor.visitSingularInt32Field(value: _storage._applicationIdentifier, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TimeProfile, rhs: Proto_TimeProfile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._hour != rhs_storage._hour {return false}
        if _storage._minute != rhs_storage._minute {return false}
        if _storage._days != rhs_storage._days {return false}
        if _storage._active != rhs_storage._active {return false}
        if _storage._applicationIdentifier != rhs_storage._applicationIdentifier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SigPosStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigPosStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "horn_repeat"),
    2: .standard(proto: "horn_type"),
    3: .standard(proto: "light_type"),
    4: .standard(proto: "sigpos_duration"),
    5: .standard(proto: "sigpos_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.hornRepeat)
      case 2: try decoder.decodeSingularEnumField(value: &self.hornType)
      case 3: try decoder.decodeSingularEnumField(value: &self.lightType)
      case 4: try decoder.decodeSingularInt32Field(value: &self.sigposDuration)
      case 5: try decoder.decodeSingularEnumField(value: &self.sigposType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hornRepeat != 0 {
      try visitor.visitSingularInt32Field(value: self.hornRepeat, fieldNumber: 1)
    }
    if self.hornType != .hornOff {
      try visitor.visitSingularEnumField(value: self.hornType, fieldNumber: 2)
    }
    if self.lightType != .lightOff {
      try visitor.visitSingularEnumField(value: self.lightType, fieldNumber: 3)
    }
    if self.sigposDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.sigposDuration, fieldNumber: 4)
    }
    if self.sigposType != .lightOnly {
      try visitor.visitSingularEnumField(value: self.sigposType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SigPosStart, rhs: Proto_SigPosStart) -> Bool {
    if lhs.hornRepeat != rhs.hornRepeat {return false}
    if lhs.hornType != rhs.hornType {return false}
    if lhs.lightType != rhs.lightType {return false}
    if lhs.sigposDuration != rhs.sigposDuration {return false}
    if lhs.sigposType != rhs.sigposType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SigPosStart.HornType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HORN_OFF"),
    1: .same(proto: "HORN_LOW_VOLUME"),
    2: .same(proto: "HORN_HIGH_VOLUME"),
  ]
}

extension Proto_SigPosStart.LightType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_OFF"),
    1: .same(proto: "DIPPED_HEAD_LIGHT"),
    2: .same(proto: "WARNING_LIGHT"),
  ]
}

extension Proto_SigPosStart.SigposType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_ONLY"),
    1: .same(proto: "HORN_ONLY"),
    2: .same(proto: "LIGHT_AND_HORN"),
    3: .same(proto: "PANIC_ALARM"),
  ]
}

extension Proto_TheftalarmConfirmDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmConfirmDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmConfirmDamagedetection, rhs: Proto_TheftalarmConfirmDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectDamagedetection, rhs: Proto_TheftalarmDeselectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectInterior, rhs: Proto_TheftalarmDeselectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectTow, rhs: Proto_TheftalarmDeselectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectDamagedetection, rhs: Proto_TheftalarmSelectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectInterior, rhs: Proto_TheftalarmSelectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectTow, rhs: Proto_TheftalarmSelectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "alarm_duration_in_seconds", json: "alarmduration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.alarmDurationInSeconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alarmDurationInSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.alarmDurationInSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStart, rhs: Proto_TheftalarmStart) -> Bool {
    if lhs.alarmDurationInSeconds != rhs.alarmDurationInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStop, rhs: Proto_TheftalarmStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AutomaticValetParkingActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutomaticValetParkingActivate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "booking_id"),
    2: .standard(proto: "drive_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.bookingID)
      case 2: try decoder.decodeSingularEnumField(value: &self.driveType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bookingID.isEmpty {
      try visitor.visitSingularStringField(value: self.bookingID, fieldNumber: 1)
    }
    if self.driveType != .unknownDriveType {
      try visitor.visitSingularEnumField(value: self.driveType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AutomaticValetParkingActivate, rhs: Proto_AutomaticValetParkingActivate) -> Bool {
    if lhs.bookingID != rhs.bookingID {return false}
    if lhs.driveType != rhs.driveType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeFlapUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeFlapUnlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeFlapUnlock, rhs: Proto_ChargeFlapUnlock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeCouplerUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeCouplerUnlock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeCouplerUnlock, rhs: Proto_ChargeCouplerUnlock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
